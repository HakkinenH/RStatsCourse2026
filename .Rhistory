source("../code/0Packages.R")
source("../code/0Packages.R")
if(!require("ggResidpanel")) install.packages("ggResidpanel")
?require
require("ggResidpanel")
if(!require("interactions")) install.packages("ggResidpanel")
if(!require("ggResidpanel")) install.packages("ggResidpanel")
if(!require("patchwork")) install.packages("patchwork")
if(!require("sjPlot")) install.packages("sjPlot")
if(!require("ggplot2")) install.packages("ggplot2")
if(!require("performance")) install.packages("performance")
if(!require("see")) install.packages("see")
if(!require("boot")) install.packages("boot")
if(!require("car")) install.packages("car")
if(!require("DHARMa")) install.packages("DHARMa")
if(!require("ggeffects")) install.packages("ggeffects")
if(!require("gratia")) install.packages("gratia")
if(!require("ggthemes")) install.packages("ggthemes")
if(!require("abe")) install.packages("abe")
if(!require("MuMIn")) install.packages("MuMIn")
if(!require("glmnet")) install.packages("glmnet")
if(!require("glmm")) install.packages("glmm")
if(!require("MASS")) install.packages("MASS")
if(!require("nlme")) install.packages("nlme")
library(abe)
library(MuMIn)
library(glmnet)
library(lme4)
library(glmm)
library(MASS)
library(nlme)
library(ggResidpanel)
library(patchwork)
library(sjPlot)
library(ggplot2) # for plots
library(performance)
library(see)
library(boot)
library(car)
library(DHARMa)
library(mgcv)
library(ggeffects)
library(gratia)
library(ggthemes)
library(interactions)
if(!require("seacarb")) install.packages("seacarb")
#####################################################
# LINEAR MODELS
#####################################################
#This file provides a worked examples of:
#Linear Regression (normal distribution response ~ continuous)
#More complex linear regression example with plots and multiple variables
#it also has some notes on:
#Non-parametric tests
#testing for normality
#Standardised variables
######################################################
#Clear your previous work
rm(list=ls())
#set your working directory
#I'm lazy so I autodetect where this file is and set it one level higher
#if this fails for any reason, set setwd manually to the folder path
curpath<-dirname(rstudioapi::getSourceEditorContext()$path)
curpath
setwd(curpath)
#go up a level out of the code folder for neatness
setwd("../")
#load packages
source("./code/0Packages.R")
#read in your datafile
limpets<- read.table("Data/Limpets_2018.txt", header=T)
#check it loaded properly
View(limpets)
#we want to check if limpet diameter correlates with the size of their nearest neighbour
#our basic formula is dia~nndia (names taken from df)
#our response variable:
hist(limpets$dia)
#continous and approximately normal
#our predictor variable:
hist(limpets$nndia)
#continuous, and skewed. Distribution doesn't normally matter in predictor variables
#just needs to not have massive outliers!
#we have a [continuous (normal) ~ continuous] structure
#the appropriate test is a linear regression
################### CONTINUOUS RESPONSE AND PREDICTOR (LINEAR REGRESSION) ############################################
#does the size of a limpet's neighbour affect the size of the focal limpet?
plot(limpets$nndia, limpets$dia, xlab="Nearest Limpet Diameter (mm)", ylab="Focal Limpet Diameter (mm)")
#this plot is a bit messy so I'm going to make a neater one!
#in R there are two major ways of creating plots: the base approach and through ggplot
#ggplot is a lot prettier but also very fiddly!
ggplot(limpets, aes(nndia, dia)) +
geom_point() +
xlab("Nearest Limpet Diameter (mm)") +
ylab("Focal Limpet Diameter (mm)") +
theme_bw()
#We think diameter of neightbour may correlate, so let's test it with a linear regression!
#a correlation test would also be acceptable if we don't think there's a causative link (i.e. x does not cause y)
#run lm
model2<-lm(dia~nndia, data=limpets)
#put four plots in the same window
par(mfrow=c(2,2))
#check the model
plot(model2)
#do residuals look ok?
#residuals can tell you a lot of info about your model.
#In effect you are fitting a line of best fit to your data, but no line is perfect
#residuals represent how far your data points are from your line of best fit
#points will either be above your line (positive) or below (negative)
#you want your line to go straight through the middle of your data so plot your residuals to find this out
#I recommend doing some reading on this, but bottom line is
#top left plot should be symmetrical around 0 (50% positive residualand 50% negative)
#top right plot should lie approximately on the diagonal line
#if your residuals look ok your model probably fits quite well!
#reset back to only one plot in the same window
par(mfrow=c(1,1))
#check output
summary(model2)
#what can we conclude?
#nndia has a significant relationship with dia (p<2.2e-16 which is 0.000000000000000022). P value is less than 0.05 so we reject the null
#equation of our straight line is dia= 29.95 + 0.28*nndia
#intercept is 29.95 (when nndia is 0, dia is 29.95)
#slope of the relationship is 0.288. So for every 1mm nndia increases, dia increases by 0.288
#R-squared is 0.058, which is very small.
#A R-squared of 1 would mean all points lie on the line of best fit
#A R-squared of 0 means all points are miles away from the line of best fit
#From this we conclude that as neighbouring limpet diameter increases the diameter of the focal limpet also increases
#however this relationship is quite weak, even though it is significant.
#make a new and improved plot
plot(limpets$nndia, limpets$dia,
col="blue", cex=0.6,
xlab="Neighbour Diameter (mm)",
ylab="Focal Limpet Diameter (mm)")
abline(model2)
################### A MORE COMPLEX LINEAR REGRESSION EXAMPLE ############################################
#the above example looked at a single predictor
#but linear models can look at a lot more than that!
#we can look at multiple effects at once, and how they may interact
#As a more complex example, we will look at the Sky Whale data
### LOAD AND EXPLORE DATA
df1<-read.delim("Data/SkyWhales_2024.txt", sep=" ")
#check data has loaded properly
# View(df1)
head(df1) #does this look as we expect?
dim(df1) #dimensions of data
#check summary, what is numeric, what is categorical? Any count data?
summary(df1)
#spotted an issue: site should be categorical (i.e. factor)
df1$site<-as.factor(df1$site)
#plot an example set of possibly correlated variables
#do sky whales get larger linearly as they age?
ggplot(df1, aes(age, length_m)) +
geom_point() +
xlab("Estimated age (years)") +
ylab("Whale length (m)")
#some signs of positive correlation, but a lot of variability in the data
ggplot(df1, aes(magic_thaums, length_m)) +
geom_point() +
ylim(0,90)+
xlab("Ambiant Magic (thaums)") +
ylab("Whale length (m)")
#much stronger correlation by the looks of things
#1) DESIGN OUR MODEL
#check the distribution of the reponse variables
hist(df1$length_m)
#nearly normal!
#so we will use a model based around a normal distribution
#what are our predictive variables and what type of data are they?:
# age (continuous), magic_thaums (continuous), location (categorical)
#so our full model will be:
#length_m ~ age+magic_thaums+location
### 2) DO PREDICTORS CORRELATE?
#this is a new step we haven't worried about before
#when you have multiple predictors, we have to check they don't correlate too much
#if they do then the model cannot distinguish what is causing the correlation
#check with a spearman correlation
cor(df1$age, df1$magic_thaums) #low, >0.5 is a warning, >0.7 is a big problem, this is fine!
#checking for lack of cross factoring with categorical is tricky, but boxplot is a useful way to check, should ideally be overlapping to some degree
boxplot(df1$age~df1$location)
boxplot(df1$magic_thaums~df1$location)
#all looks good to me
### 3) RUN THE MODEL
#our full model is Whale Length ~ age + environmental background magic + location
#I have chosen to use unscaled variables here but we could always change this later
lm1 <- lm(length_m ~ age+magic_thaums+location, data = df1)
### 4) RESIDUAL CHECKS
#check the model fit and residuals!
par(mfrow=c(2,2)); plot(lm1)
#they look good! But to be sure, we can have a look at some more diagnostics
par(mfrow=c(1,1));
car::qqPlot(lm1, id=FALSE)
#definitely a good fit! The residuals nearly all fall within an expected random distribution (blue shading)
resid_panel(lm1)
# to create the multi-panel plot
dplots <- sjPlot::plot_model(lm1, type="diag")
((dplots[[1]] + dplots[[2]])/ dplots[[3]])
dplots <- sjPlot::plot_model(lm1, type="diag")
((dplots[[1]] + dplots[[2]])/ dplots[[3]])
#and yet another way!
check_model(lm1, check = c("linearity", "homogeneity", "qq", "normality"))
#Clear your previous work
rm(list=ls())
#set your working directory
#I'm lazy so I autodetect where this file is and set it one level higher
#if this fails for any reason, set setwd manually to the folder path
curpath<-dirname(rstudioapi::getSourceEditorContext()$path)
curpath
setwd(curpath)
#go up a level out of the code folder for neatness
setwd("../")
#load packages
source("./code/0Packages.R")
#############
### LOAD AND EXPLORE DATA
#############
#read in data
gala<-read.csv("data/gala.csv")
#we are interested in how area predicts species diversity, what is the relationship?
plot(gala$Area, gala$Species)
#obviously non-linear! This cannot be modelled easily, due to the high outliers
#from previous experience, I know that the logArea is more likely to linearly correlate with diversity
#I will attempt a transformation to see if it makes the data more linear
#what does that look like?
gala$logarea<-log10(gala$Area)
plot(gala$logarea, gala$Species)
#still not linear! An obvious curve
#check distribution of response data
hist(gala$Species, breaks=20)
#not normally distributed. this looks like a curve
#what do we do with this? Well we have a lot of choices
#based on our quick transformation above, I think transformation is the wrong choice
#but let's look at a quick example where a data transformation can help!
#############
### Data transformations
#############
#sometimes data does not fit a distribution neatly
df1<-read.csv("Data/Succession.txt")
plot(df1$days, df1$population)
hist(df1$population)
hist(df1$log_population)
df1$log_population <- log10(df1$population)
hist(df1$log_population)
hist(df1$population)
hist(df1$population, main=Population Size, xlab=n)
hist(df1$population, main="Population Size", xlab=n)
hist(df1$population, main="Population Size", xlab="n")
hist(df1$log_population, main="log10(Population Size)", xlab="n"))
hist(df1$log_population, main="log10(Population Size)", xlab="n")
hist(df1$population, main="Population Size", xlab="n")
hist(df1$log_population, main="log10(Population Size)", xlab="n")
